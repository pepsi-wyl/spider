 
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
    </head>
    <body>
    <p class="site-subtitle">给时光以生命。</p> <p>在看Kenneth Reitz大神的<a href="https://github.com/kennethreitz/records" rel="noopener" target="_blank">Records项目</a>时，注意到在Readme中，读取数据有三种写法：</p> <p>Values can be accessed many ways: row.user_email row[‘user_email’] or row[3]</p> <p>假设一个数据表如下所示：</p> <p>那么，当你想读取user_email这一列的时候，除了可以使用<code>row.user_email</code>和<code>row['user_email']</code>以外，由于<code>user_email</code>在第3列（username是第0列），所以还可以使用<code>row[3]</code>来读取。</p> <p>今天我们就来研究一下，他是如何实现这个功能的。</p> <p>假设我们现在有一个类：</p> <p>基于这个类初始化一个对象kingname:</p> <p>运行效果如下图所示：</p> <p><img alt="" src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-07-07-22-02-56.png"/></p> <p>可以看到，我们已经实现了类似于records项目中的<code>row.user_email</code>的写法。</p> <p>但是当我们想像字典一样取读取的时候，就会报错，如下图所示。</p> <p><img alt="" src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-07-07-22-04-11.png"/></p> <p>此时，为了让一个对象可以像字典一样被读取，我们需要实现它的<code>__getitem__</code>方法：</p> <p>此时就可以像字典一样去读取了，运行效果如下图所示：</p> <p><img alt="" src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-07-07-22-10-00.png"/></p> <p>但新的问题又来了，不能直接读取使用<code>kinganme.age</code>读取数据了，这样写会导致报错，如下图所示：</p> <p><img alt="" src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-07-07-22-10-57.png"/></p> <p>为了解决这个问题，我们再来实现这个类的<code>__getattr__</code>方法：</p> <p>运行效果如下图所示：</p> <p><img alt="" src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-07-07-22-13-11.png"/></p> <p>那么如何实现records里面的<code>row[3]</code>这种写法呢？这就需要先解释一下，records这个库是用来做什么的，以及它的数据是如何存放的。</p> <p>K大写的records这个库，是用于来更加方便地读写SQL数据库，避免繁琐地写各种SQL语句。</p> <p>这个库的源代码只有一个文件：<a href="https://github.com/kennethreitz/records/blob/master/records.py" rel="noopener" target="_blank">源代码</a></p> <p>我们今天要研究的这个写法，在<code>Record</code>这个类里面。这个类用来保存MySQL中的一行数据。<code>Record</code>这个类包含两个属性，分别为<code>_keys</code>和<code>_values</code>，其中<code>_keys</code>用于记录所有的字段名，<code>_values</code>用于记录一行的所有值。字段名和值是按顺序一一对应的。</p> <p>例如<code>_keys</code>里面下标为3表示字段名<code>user_email</code>，那么<code>_values</code>里面下标为3的数据就是<code>user_email</code>的值。</p> <p>正式由于这样一个一一对应的关系，所以<code>row[3]</code>才能实现<code>row['user_email']</code>、<code>row.user_email</code>相同的效果。</p> <p>回到我们的People类，为了实现相同的目的，我们再次修改代码：</p> <p>运行效果如下图所示：</p> <p><img alt="" src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-07-07-22-25-28.png"/></p> <p>需要说明的是，无论是使用<code>kingname['key']</code>还是<code>kingname[1]</code>，他们都会进入到<code>__getitem__</code>方法中去。</p> <p>我这里给出的例子相较于<code>records</code>项目的代码做了简化，不过关键的部分都已经囊括了进来。</p> <p>最后，推荐有兴趣的同学通读records这个项目的源代码，你将会从K大的代码中学到非常多的东西。</p> <p class="site-author-name" itemprop="name">谢乾坤 | Kingname</p> <p class="site-description motion-element" itemprop="description">高级数据挖掘工程师，《Python 爬虫开发 从入门到实战》、《左手 MongoDB 右手 Redis——从入门到商业实战》作者。 微软最有价值专家 MVP，Python Scrapy MongoDB Redis Pandas Golang。</p>
    </body>
    </html>
    