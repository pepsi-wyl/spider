 
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
    </head>
    <body>
    <p class="site-subtitle">给时光以生命。</p> <p>在<a href="http://jikexueyuan.com" rel="noopener" target="_blank">极客学院</a>讲授《使用Python编写远程控制程序》的课程中，涉及到查看被控制电脑屏幕截图的功能。</p> <p>如果使用PIL，这个需求只需要三行代码：<br/><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageGrab</span><br/><span class="line">pic = ImageGrab.grab()</span><br/><span class="line">pic.save(<span class="string">'1.jpg'</span>)</span><br/></pre></td></tr></table></figure></p> <p>但是考虑到被控端应该尽量的精简，对其他模块尽量少的依赖，这样才能比较方便的部署，因此我考虑能否有一种方法，不依赖PIL来实现截图的功能。</p> <p>由于被控端使用了win32api 因此有一个方法：<br/><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line">win32api.keybd_event</span><br/></pre></td></tr></table></figure></p> <p>这个方法可以模拟键盘的按键动作。因此，解决方法就比较的明显了：</p> <p>第一步非常的简单，实用win32api 和 win32con，两行代码就能实现：<br/><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/></pre></td><td class="code"><pre><span class="line">import win32api</span><br/><span class="line">import win32con</span><br/><span class="line">win32api.keybd_event(win32con.VK_SNAPSHOT 0)</span><br/></pre></td></tr></table></figure></p> <p>其中win32con这个库里面包含了很多定义好的和Windows相关的常量，而VK_SNAPSHOT就是Print Screen键的键位码。后面的数字0表示截取整个屏幕。如果改成数字1，表示截取当前窗口。</p> <p>那么现在问题来了，在不实用PIL的情况下，如何将剪贴板你们的图片保存到本地？</p> <p>win32api有一个模块 win32clipboard 是负责剪贴板相关的操作。它有一个方法：<br/><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line">win32clipboard.GetClipboardData(formats)</span><br/></pre></td></tr></table></figure></p> <p>这个方法可以从剪贴板里面读取数据。但是需要指定数据的格式。从<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ff729168\(v=vs.85\" rel="noopener" target="_blank">这里</a>.aspx)可以查看到更多的标准剪贴板格式(<em>Standard Clipboard Formats</em>).</p> <p>一开始我使用的formats是<strong>CF_BITMAP</strong>，程序返回的是一串整数，怀疑应该是一个内存地址。这也和这个format的描述：</p> <p>A handle to a bitmap (<strong>HBITMAP</strong>).</p> <p>是一致的，它是一个handle。</p> <p>我也尝试过CF_TIFF 不过程序直接报错了，可见我使用Print Screen截图以后，剪贴板里面的图片格式并不是TIFF。</p> <p>经过查阅其他资料，我最后确定使用了CF_DIB。</p> <p>A memory object containing a BITMAPINFO structure followed by the bitmap bits.</p> <p>这个描述说明，CF_DIB返回的是一个内存对象，包含了BIT格式图片的信息。经过测试使用：<br/><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line">win32clipboard.GetClipboardData(win32con.CF_DIB)</span><br/></pre></td></tr></table></figure></p> <p>以后，可以得到一个很大的字符串。显然这个字符串就是图片的内容了。但是当我把这个字符串写入到bmp格式的文件后，却发现图片无法打开。</p> <p>在StackOverflow上，我遇到了一个非常好的老先生： <a href="https://stackoverflow.com/users/355230/martineau" rel="noopener" target="_blank">Mr. martineau</a>他为了解答了问题，并给我提供了解决办法。以下内容翻译自martineau先生的回答，原文请戳-&gt;<a href="https://stackoverflow.com/a/35885108/3922976" rel="noopener" target="_blank">http://stackoverflow.com/a/35885108/3922976</a></p> <p>你的方法的主要问题在于，你写入文件的字符串缺少了.bmp 文件头，这个文件头是<code>BITMAPFILEHEADER</code>结构。</p> <p>为了创建这个文件头，使用<code>GetClipboardData()</code>返回的字符串必须要进行解码(<em>decoded</em>)。对于<code>CF_DIB</code>格式来说，返回的字符串的前面一部分就是<code>BOTMAPINFOHEADER</code>。</p> <p>对于各种各样有不同种类压缩的<code>DIB</code>来说，这种文件头结构是非常的普遍的。不过幸好对截图来说，只需要简单的无压缩的RGBA像素。</p> <p>由于<code>BOTMAPFILEHEADER</code>被放在了bf0ffBits的区域里，所以事情就变得很容易了。而其他的情况，例如大尺度的颜色表跟在<code>BITMAPINFOHEADER</code> 和像素数组的开头。</p> <p>（这一段我看不太懂，还请如果有能正确解释这段话的朋友指正。原文是：</p> <p>That fact makes things much easier because otherwise determining the value to put in the bfOffBits field of the BITMAPFILEHEADER would be complicated by the fact that in most other cases there’s also a variably-sized color table following the BITMAPINFOHEADER and the start of the pixel array.）</p> <p>下面的代码是一个简单的例子（仅仅针对这个需求）：<br/><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/><span class="line">20</span><br/><span class="line">21</span><br/><span class="line">22</span><br/><span class="line">23</span><br/><span class="line">24</span><br/><span class="line">25</span><br/><span class="line">26</span><br/><span class="line">27</span><br/><span class="line">28</span><br/><span class="line">29</span><br/><span class="line">30</span><br/><span class="line">31</span><br/><span class="line">32</span><br/><span class="line">33</span><br/><span class="line">34</span><br/><span class="line">35</span><br/><span class="line">36</span><br/><span class="line">37</span><br/><span class="line">38</span><br/><span class="line">39</span><br/><span class="line">40</span><br/><span class="line">41</span><br/><span class="line">42</span><br/><span class="line">43</span><br/><span class="line">44</span><br/><span class="line">45</span><br/><span class="line">46</span><br/><span class="line">47</span><br/><span class="line">48</span><br/><span class="line">49</span><br/><span class="line">50</span><br/><span class="line">51</span><br/><span class="line">52</span><br/><span class="line">53</span><br/><span class="line">54</span><br/><span class="line">55</span><br/><span class="line">56</span><br/><span class="line">57</span><br/><span class="line">58</span><br/><span class="line">59</span><br/><span class="line">60</span><br/><span class="line">61</span><br/><span class="line">62</span><br/><span class="line">63</span><br/><span class="line">64</span><br/></pre></td><td class="code"><pre><span class="line">import ctypes</span><br/><span class="line">from ctypes.wintypes import *</span><br/><span class="line">import win32clipboard</span><br/><span class="line">from win32con import *</span><br/><span class="line">import sys</span><br/><span class="line"></span><br/><span class="line">class BITMAPFILEHEADER(ctypes.Structure):</span><br/><span class="line">    _pack_ = 1  # structure field byte alignment</span><br/><span class="line">    _fields_ = [</span><br/><span class="line">        ('bfType' WORD)  # file type ("BM")</span><br/><span class="line">        ('bfSize' DWORD)  # file size in bytes</span><br/><span class="line">        ('bfReserved1' WORD)  # must be zero</span><br/><span class="line">        ('bfReserved2' WORD)  # must be zero</span><br/><span class="line">        ('bfOffBits' DWORD)  # byte offset to the pixel array</span><br/><span class="line">    ]</span><br/><span class="line">SIZEOF_BITMAPFILEHEADER = ctypes.sizeof(BITMAPFILEHEADER)</span><br/><span class="line"></span><br/><span class="line">class BITMAPINFOHEADER(ctypes.Structure):</span><br/><span class="line">    _pack_ = 1  # structure field byte alignment</span><br/><span class="line">    _fields_ = [</span><br/><span class="line">        ('biSize' DWORD)</span><br/><span class="line">        ('biWidth' LONG)</span><br/><span class="line">        ('biHeight' LONG)</span><br/><span class="line">        ('biPLanes' WORD)</span><br/><span class="line">        ('biBitCount' WORD)</span><br/><span class="line">        ('biCompression' DWORD)</span><br/><span class="line">        ('biSizeImage' DWORD)</span><br/><span class="line">        ('biXPelsPerMeter' LONG)</span><br/><span class="line">        ('biYPelsPerMeter' LONG)</span><br/><span class="line">        ('biClrUsed' DWORD)</span><br/><span class="line">        ('biClrImportant' DWORD)</span><br/><span class="line">    ]</span><br/><span class="line">SIZEOF_BITMAPINFOHEADER = ctypes.sizeof(BITMAPINFOHEADER)</span><br/><span class="line"></span><br/><span class="line">win32clipboard.OpenClipboard()</span><br/><span class="line">try:</span><br/><span class="line">    if win32clipboard.IsClipboardFormatAvailable(win32clipboard.CF_DIB):</span><br/><span class="line">        data = win32clipboard.GetClipboardData(win32clipboard.CF_DIB)</span><br/><span class="line">    else:</span><br/><span class="line">        print('clipboard does not contain an image in DIB format')</span><br/><span class="line">        sys.exit(1)</span><br/><span class="line">finally:</span><br/><span class="line">    win32clipboard.CloseClipboard()</span><br/><span class="line"></span><br/><span class="line">bmih = BITMAPINFOHEADER()</span><br/><span class="line">ctypes.memmove(ctypes.pointer(bmih) data SIZEOF_BITMAPINFOHEADER)</span><br/><span class="line"></span><br/><span class="line">if bmih.biCompression != BI_BITFIELDS:  # RGBA?</span><br/><span class="line">    print('insupported compression type {}'.format(bmih.biCompression))</span><br/><span class="line">    sys.exit(1)</span><br/><span class="line"></span><br/><span class="line">bmfh = BITMAPFILEHEADER()</span><br/><span class="line">ctypes.memset(ctypes.pointer(bmfh) 0 SIZEOF_BITMAPFILEHEADER)  # zero structure</span><br/><span class="line">bmfh.bfType = ord('B') | (ord('M') &lt;&lt; 8)</span><br/><span class="line">bmfh.bfSize = SIZEOF_BITMAPFILEHEADER + len(data)  # file size</span><br/><span class="line">SIZEOF_COLORTABLE = 0</span><br/><span class="line">bmfh.bfOffBits = SIZEOF_BITMAPFILEHEADER + SIZEOF_BITMAPINFOHEADER + SIZEOF_COLORTABLE</span><br/><span class="line"></span><br/><span class="line">bmp_filename = 'clipboard.bmp'</span><br/><span class="line">with open(bmp_filename 'wb') as bmp_file:</span><br/><span class="line">    bmp_file.write(bmfh)</span><br/><span class="line">    bmp_file.write(data)</span><br/><span class="line"></span><br/><span class="line">print('file "{}" created from clipboard image'.format(bmp_filename))</span><br/></pre></td></tr></table></figure></p> <p>经过测试，这一段代码成功的实现了读取剪贴板的图片并保存到本地。</p> <p>这段代码使用ctypes库来实现指针的功能，从而在内存中操作数据。这里定义了两个结构体，<code>BITMAPFILEHEADER</code> 和<code>BITMAPINFOHEADER</code>，于是，使用sizeof获取到了他们的大小。那么使用指针，从使用<code>GetClipboardData()</code>获取到的数据的头部开始移动，分别移动这两个结构体的大小，也就获取到了这两个结构体在内存中的数据。</p> <p>代码中使用了<code>memmove</code>和<code>memset</code>两个内存操作的方法。从ctypes的官方文档上，我们可以看到这两个方法有如下的定义：</p> <p><code>ctypes.memmove(dst src count)</code></p> <p>Same as the standard C memmove library function: copies count bytes from src to dst. dst and src must be integers or ctypes instances that can be converted to pointers.</p> <p><code>ctypes.memset(dst c count)</code></p> <p>Same as the standard C memset library function: fills the memory block at address dst with count bytes of value c. dst must be an integer specifying an address or a ctypes instance.</p> <p>所以可以看出，代码里面的：<br/><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/></pre></td><td class="code"><pre><span class="line">bmih = BITMAPINFOHEADER()</span><br/><span class="line">ctypes.memmove(ctypes.pointer(bmih) data SIZEOF_BITMAPINFOHEADER)</span><br/></pre></td></tr></table></figure></p> <p>从内存中拷贝出来了<code>BITMAPINFOHEADER</code>这么大的一块的数据，并保存到了<code>bmih</code>这个变量中。<br/><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/></pre></td><td class="code"><pre><span class="line">bmfh = BITMAPFILEHEADER()</span><br/><span class="line">ctypes.memset(ctypes.pointer(bmfh) 0     SIZEOF_BITMAPFILEHEADER)</span><br/></pre></td></tr></table></figure></p> <p>这一段在内存中开辟出了<code>BITMAPFILEHEADER</code>这么大一块区域，并全部填充为0.<br/><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line">bmfh.bfType = ord('B') | (ord('M') &lt;&lt; 8)</span><br/></pre></td></tr></table></figure></p> <p>这一行代码使用了位操作。首先<code>ord('B')</code>的值为66，换成二进制就是<code>1000010</code>；<code>ord('M')</code>的值为77，换成二进制就是<code>1001101</code>，然后向左移动8位，得到<code>100110100000000</code>，这个值再与<code>1000010</code>取位或，得到<code>100110101000010</code>。</p> <p>最后，使用：<br/><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line">bmfh.bfOffBits = SIZEOF_BITMAPFILEHEADER + SIZEOF_BITMAPINFOHEADER + SIZEOF_COLORTABLE</span><br/></pre></td></tr></table></figure></p> <p>拼装出头部的大小。然后以二进制方式，首先写文件头 再写剪贴板获取到的字符串到本地的<code>.bmp</code>文件中，完成图片的生成。</p> <p>Python一些轮子确实非常好的提高了开发效率，例如PIL，三行代码实现了我的需求。Python在快速开发方面确实非常的方便，但是涉及到底层的一些操作的时候，还是不得不使用C语言的一些接口来进行内存的操作。</p> <p class="site-author-name" itemprop="name">谢乾坤 | Kingname</p> <p class="site-description motion-element" itemprop="description">高级数据挖掘工程师，《Python 爬虫开发 从入门到实战》、《左手 MongoDB 右手 Redis——从入门到商业实战》作者。 微软最有价值专家 MVP，Python Scrapy MongoDB Redis Pandas Golang。</p>
    </body>
    </html>
    