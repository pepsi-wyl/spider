 
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
    </head>
    <body>
    <p class="site-subtitle">给时光以生命。</p> <p>在我的爬虫书中，讲到了使用 Charles 或者 MitmProxy 实现中间人攻击，从而绕过反爬虫机制的方法。但这两种方法都需要安装根证书。</p> <p>今天，我们来试一试在 Puppeteer 中，使用中间人攻击，攻击目标是我们自己，来绕过反爬虫机制。</p> <p>首先，我们用以下代码访问网站<code>http://exercise.kingname.info/exercise_ajax_1.html</code>：</p> <p>运行效果如下图所示：</p> <p><img alt="" src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2022-01-05-19-57-05.png"/></p> <p>现在，我想拦截网站返回的数据，并篡改它。首先我们打开 Chrome 的开发者工具，看看这个页面有哪些 Ajax 请求：</p> <p><img alt="" src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2022-01-05-19-58-54.png"/></p> <p>红框框住的这个 Ajax 请求，返回了网页上面的文字。这个请求对应的地址是：<code>http://exercise.kingname.info/ajax_1_backend</code>，如下图所示：</p> <p><img alt="" src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2022-01-05-19-59-51.png"/></p> <p>现在，我们就来尝试篡改这个请求的返回数据。首先使用<code>npm</code>安装一个包：<code>npm install puppeteer-interceptor</code>。然后修改代码：</p> <p>运行效果如下图所示：</p> <p><img alt="" src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2022-01-05-20-06-35.png"/></p> <p>其中关键的代码如下：</p> <p>这一段代码指定，要修改一个 XHR 请求的返回。这个 XHR 请求的 URL 是以<code>ajax_1_backend</code>结尾的。所谓的 XHR 请求，全称是<code>XMLHttpRequest</code>，大家可以把它近似看做 Ajax 请求。</p> <p>当检测到满足这个通配符的请求时，无论它的内容是什么，都改写成<code>You are hacked by me</code>，然后返回给浏览器。</p> <p>有人可能会问，你这样修改，简单是简单，但它有什么用呢？它的用处非常大，比如你在做爬虫的时候，把网站的 JavaScript 的一部分代码替换了，这样就能绕过反爬虫检测。</p> <p>我做了一个示例的页面来说明。这个页面直接访问，如下图所示：</p> <p><img alt="" src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2022-01-05-20-26-57.png"/></p> <p>使用开发者工具，我们可以看到核心的反爬虫逻辑在<code>http://127.0.0.1:8000/backend.js</code>这个 js 文件中，如下图所示：</p> <p><img alt="" src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2022-01-05-20-29-35.png"/></p> <p>这个演示的例子中，这个反爬虫函数非常简单。但在真实的场景中，它的逻辑非常复杂。然而，逻辑再复杂，也有个调用入口。简单分析这个JavaScript 代码，我们可以知道，只需要把代码第14行注释掉，强制设置<code>is_spider = false</code>，就可以绕过这个反爬虫逻辑了。</p> <p>为了绕过反爬虫逻辑，首先，我们把网站的这个JavaScript 代码复制下来，保存成<code>safe.js</code>文件。然后修改里面的代码，绕过反爬虫逻辑：</p> <p>接下来，修改 Puppeteer 的代码，从本地读取这个修改后的 js 文件，然后拦截真正的请求并使用修改后的代码替换：</p> <p>运行效果如下图所示：</p> <p><img alt="" src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2022-01-05-20-57-28.png"/></p> <p>从图中可以看到，我们成功绕过了反爬虫的逻辑，获得了真正的页面数据。</p> <p>这里有两个地方需要注意：</p> <p><code>puppeteer-interceptor</code>不仅可以修改返回的内容，还可以修改网站的请求。更多强大功能，大家可以阅读它的<a href="https://www.npmjs.com/package/puppeteer-interceptor" rel="noopener" target="_blank">官方文档</a>。</p> <p class="site-author-name" itemprop="name">谢乾坤 | Kingname</p> <p class="site-description motion-element" itemprop="description">高级数据挖掘工程师，《Python 爬虫开发 从入门到实战》、《左手 MongoDB 右手 Redis——从入门到商业实战》作者。 微软最有价值专家 MVP，Python Scrapy MongoDB Redis Pandas Golang。</p>
    </body>
    </html>
    