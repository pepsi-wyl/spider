 
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
    </head>
    <body>
    <p class="site-subtitle">给时光以生命。</p> <p>看过《Python爬虫开发 从入门到实战》的同学，应该对<code>multiprocessing</code>这个模块比较熟悉，在书上我使用这个模块通过几行代码实现了一个简单的多线程爬虫:</p> <p>运行效果如下图所示：</p> <p><img alt="" src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-08-01-12-41-43.png"/></p> <p>（没有看过我的书的人可能会质疑，<code>multiprocessing</code>不是多进程模块吗？为什么你说是多线程？看过书的读者不会有这个疑惑，因为我在书上解释过原因）</p> <p>现在，你有一个函数，没有任何参数，但是仍然想让他使用多线程，于是模仿上面的代码，你这样写：</p> <p>运行以后发现，什么都没有打印出来，也就是说<code>test()</code>函数根本没有运行。</p> <p>如果你强行给函数添加一个没用的参数，结果又正常了：</p> <p>运行效果如下图所示。<br/><img alt="" src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-08-01-13-11-04.png"/></p> <p>所以你隐隐觉得，如果<code>pool.map</code>的第二个参数是空的可迭代对象，那么函数就不会运行。</p> <p>（当然，使用过Python自带的<code>map</code>函数的同学肯定直接就知道这一点，不过本文依然使用它来做例子，用于说明阅读源代码的方法。）</p> <p>为了证明这一点，我们打开<code>Python安装目录/lib/multiprocessing/pool.py</code>文件，在里面找到<code>def map(self func iterable chunksize=None)</code>这一行，如下图所示：</p> <p><img alt="" src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-08-01-13-24-17.png"/></p> <p>（本文使用Python 3.7.3作为演示，如果你的Python版本不是3.7.3，那么代码可能会有一些区别）</p> <p>从代码里面可以看到，这里调用了<code>self._map_async()</code>，传入参数，获得返回值以后，再调用了返回值的<code>.get()</code>方法。</p> <p>所以继续看<code>self._map_async()</code>方法：</p> <p><img alt="" src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-08-01-13-25-55.png"/></p> <p>在这个方法里面，如果我们传入的可迭代对象为空，那么也就是这里的参数<code>iterable</code>为空。于是</p> <p><code>map</code>的第一个参数，函数名被传入了下面这一行代码中：</p> <p>查看<code>Pool._get_tasks</code>这个静态方法，可以看到：</p> <p><img alt="" src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-08-01-13-35-02.png"/></p> <p>由于这里的参数<code>it</code>就是空的可迭代对象，<code>size</code>为0，所以下面这一行代码返回空元组：</p> <p>这个生成器直接就会结束，最后一行<code>yield (func x)</code>根本不会执行。</p> <p>再来看代码里使用<code>MapResult</code>类初始化了一个result对象，然后返回这个对象。</p> <p>再进入到<code>MapResult</code>类里面，如下图所示：</p> <p><img alt="" src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-08-01-13-28-24.png"/></p> <p>在这段<code>__init__</code>中，可以得到如下几个参数的值：</p> <p>关于<code>self._event.set()</code>请看我的另一篇公众号：</p> <p><a href="https://mp.weixin.qq.com/s?__biz=MzI2MzEwNTY3OQ==&amp;mid=2648977403&amp;idx=1&amp;sn=30c87656a2903197cb16b1726fec3b80&amp;chksm=f250721bc527fb0d33d3dff09fce9c369011f77048f3752dfa8ba343479c606872bde4486743&amp;token=1554445332&amp;lang=zh_CN#rd" rel="noopener" target="_blank">一日一技：Python多线程的事件监控</a></p> <p>返回的result对象的<code>.get()</code>方法被调用了。但是由于<code>MapResult</code>本身没有<code>.get()</code>方法，于是变为调用父类<code>ApplyResult</code>的<code>.get()</code>方法。</p> <p>再进入<code>ApplyResult</code>里面，查看<code>.get()</code>方法：</p> <p><img alt="" src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-08-01-21-26-57.png"/></p> <p>由于前面调用了<code>self._event.set()</code>，所以这里的<code>self.ready()</code>结果为<code>True</code>，而由于<code>self._success</code>在上面为<code>True</code>，所以这里直接<code>return self._value</code>。也就是返回一个空的列表。</p> <p>到此为止，在<code>pool.map</code>的第二个参数为空的可迭代对象时，所有的流程就走完了。整个过程中，没有涉及到任何调用<code>func</code>的过程。所以原有的函数不会被执行。</p> <p>最后说说为什么在本文中我们看的是<code>multiprocessing</code>的<code>Pool</code>类里面的<code>map</code>方法，而不是<code>multiprocessing.dummy</code>的<code>Pool</code>类里面的<code>map</code>方法。</p> <p>这是因为，如果我们打开<code>Python安装路径/Lib/multiprocessing/dummy/__init__.py</code>，我们就可以看到，它的<code>Pool</code>实际上返回的是一个<code>ThreadPool</code>对象。而这个对象的代码，实际上也在<code>Python安装路径/Lib/multiprocessing/pool.py</code>文件中，并且继承自<code>Pool</code>类。所以他们的<code>map</code>方法的代码是完全一样的。</p> <p class="site-author-name" itemprop="name">谢乾坤 | Kingname</p> <p class="site-description motion-element" itemprop="description">高级数据挖掘工程师，《Python 爬虫开发 从入门到实战》、《左手 MongoDB 右手 Redis——从入门到商业实战》作者。 微软最有价值专家 MVP，Python Scrapy MongoDB Redis Pandas Golang。</p>
    </body>
    </html>
    