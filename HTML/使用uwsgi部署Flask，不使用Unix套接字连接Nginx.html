 
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
    </head>
    <body>
    <p class="site-subtitle">给时光以生命。</p> <p>如果你在Google或者百度或者某些技术社区上面搜索<code>uwsgi + Flask</code>，你会发现大量的文章，是教你如何使用<code>uwsgi + flask + Nginx</code>搭建网站。如下图所示：</p> <p><img alt="" src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-07-08-20-31-12.png"/></p> <p>而且这些文章，全部都像是约定俗成一样，一定会首先用命令行启动uwsgi，测试uwsgi与Flask运行是否正常，然后写uwsgi的配置文件。然后使用<code>Unix 套接字</code>沟通uwsgi与Nginx。所以uwsgi的配置文件里面一定会写成类似于下面这样：</p> <p>Nginx的配置一定有类似于下面这一段：</p> <p>他们为什么要这样写？因为他们看的别的博客上就是这样写的！他们知其然，但是不知其所以然。</p> <p>这种写法本身没有问题，甚至Flask的官方文档里面也是这样写的，如下图所示：</p> <p><img alt="" src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-07-08-20-43-07.png"/></p> <p>但是他们这样写，有一个基本前提——就是Flask程序、uwsgi、Nginx三个东西运行在同一个服务器上。如果用Docker，那么这三个东西甚至需要运行到一个容器里面。</p> <p>如果是一个小网站，服务器资源足够，那么这样写没有问题，Unix套接字安全性高，速度也快。</p> <p>那么如果你同一个服务器上有三个Docker容器，每一个容器都有一个不同的网站，是不是每个容器里面都需要安装一个Nginx？</p> <p>对于大一些的网站，Nginx需要做负载均衡，如果把Nginx和网站放在同一台服务器上，无论是Nginx拖垮了服务器，还是网站拖垮了服务器，都会导致很严重的问题。</p> <p>能不能实现，一个服务器上直接安装Nginx，然后服务器上的三个网站分别在三个Docker容器里面，每个容器里面只有Flask和uwsgi，没有Nginx？</p> <p>如果你的网站大一些，你在A服务器安装Nginx，在B、C、D、E、F服务器上不安装Nginx，只安装uwsgi + Flask，又怎么做？</p> <p>所以进入我们今天的主题，<code>安装uwsgi + Flask(或者Django)，但是不安装Nginx（Deploy Flask with uwsgi but without Nginx）</code></p> <p>Unix套接字，本质上是一个文件（Unix/Linux哲学：一切皆文件），Nginx和uwsgi通过这个文件来进行通信。所以需要Nginx与uwsgi放在同一个机器上。</p> <p>但实际上，uwsgi本身就是一个服务器，A服务器上的Nginx与B服务器上的uwsgi之间是可以通过http进行通信的。</p> <p>要让uwsgi使用http进行通信，我们可以修改uwsgi的配置文件xxx.ini：</p> <p>其他参数的意义不是本文的重点，我们要关心的是<code>http-socket = 0.0.0.0:5001</code>。它的作用把网站部署在本机的5001端口，并允许外网通过http访问。</p> <p>写了这个配置文件以后，通过以下命令来启动uwsgi：</p> <p>然后你使用<code>IP:5001</code>就可以访问你的网站了。此时，如果你有Nginx，那么只需要在Nginx上设置反向代理，把80端口的请求代理到5001端口即可。</p> <p>同理，把uwsgi和网站放在Docker镜像里面，容器开放5001端口。宿主机或者其他机器上的Nginx直接通过IP:端口 就可以访问容器里面的uwsgi，不再需要设置Unix套接字了。</p> <p>另外，如果你阅读过uwsgi的官方文档，你还会发现，除了<code>http-socket = 0.0.0.0:5001</code>外，你也可以把它改成<code>http = 0.0.0.0:5001</code>。那么这两种写法是否一样呢？</p> <p>在官方文档里面特别区分了它们的使用场景：</p> <p>The http and http-socket options are entirely different beasts. The first one spawns an additional process forwarding requests to a series of workers (think about it as a form of shield at the same level of apache or nginx) while the second one sets workers to natively speak the http protocol. TL/DR: if you plan to expose uWSGI directly to the public use –http if you want to proxy it behind a webserver speaking http with backends use –http-socket.</p> <p>简言之，如果你直接把uwsgi作为服务器，uwsgi启动以后，直接就把IP:端口拿给别人访问，那么你就可以使用<code>http</code>；如果你的uwsgi前面还挡了一个Nginx，那么你就使用<code>http-socket</code>。</p> <p class="site-author-name" itemprop="name">谢乾坤 | Kingname</p> <p class="site-description motion-element" itemprop="description">高级数据挖掘工程师，《Python 爬虫开发 从入门到实战》、《左手 MongoDB 右手 Redis——从入门到商业实战》作者。 微软最有价值专家 MVP，Python Scrapy MongoDB Redis Pandas Golang。</p>
    </body>
    </html>
    