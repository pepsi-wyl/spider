 
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
    </head>
    <body>
    <p class="site-subtitle">给时光以生命。</p> <p>知乎用户<a href="https://www.zhihu.com/people/li-zhe-ao/posts" rel="noopener" target="_blank">@Manjusaka
</a>在阅读了我的文章<a href="https://zhuanlan.zhihu.com/p/70680488" rel="noopener" target="_blank">《Python正则表达式，请不要再用re.compile了！！！》</a>以后，写了一篇驳文<a href="https://zhuanlan.zhihu.com/p/78265675" rel="noopener" target="_blank">《驳 &lt;Python正则表达式，请不要再用re.compile了！！！&gt;》</a></p> <p>今天，我在这里回应一下这篇驳文。首先标题里面，我用的是<code>回</code>，意为回复，而不是继续驳斥@Manjusaka的文章。因为没有什么好驳斥的，他的观点没有什么问题。</p> <p>首先说明，我自己在公司的代码里面，也会使用<code>re.compile</code>。但是，我现在仍然坚持我的观点，让看这篇文章的人，不要用<code>re.compile</code>。</p> <p>在公司里面，我使用<code>re.compile</code>的场景是这样的：</p> <p>每两小时从10亿条字符串中，筛选出所有不符合特定正则表达式的字符串。</p> <p>这个程序可以简化为如下结构：</p> <p>在这个场景下面，对于10亿个字符串，3个正则表达式，需要循环30亿次。虽然读取正则表达式缓存的时间很短，假设只有1毫秒，那么也会浪费833小时。为了实现2小时内处理10亿条数据，我做了很多优化，其中之一就是提前<code>re.compile</code>：</p> <p>在这样的场景下，这样的数据量级下面，你是用<code>re.compile</code>，当然可以。</p> <p>然而，你日常接触到的工作，都是这个量级吗？知乎上流行一句话：</p> <p>抛开剂量谈毒性，都是耍流氓。</p> <p>同样的，在数据处理上也适用：</p> <p>抛开量级谈性能差异，都是耍流氓</p> <p>处理几百条数据，还需要担心读取缓存字典的这点小小的性能开销？</p> <p>我在另一篇文章<a href="https://zhuanlan.zhihu.com/p/73426505" rel="noopener" target="_blank">为什么Python 3.6以后字典有序并且效率更高？</a>中提到，从Python 3.6开始，字典不会再提前申请更多空间了，同时也变得有序了，作为代价就是从字典读取值的过程多了一步。多出来的这一步实际上也会有性能开销，因为它需要先查询<code>indices</code>，然后再查询<code>entries</code>。为什么Python愿意放弃性能而要让字典有序？因为新的实现方式，在整体迭代、空间利用率上面都更高。</p> <p>回到正则表达式的例子来，Python区别于其他语言的一个非常重要的点是什么？是它的自文档性。</p> <p>网上有这样一个段子：</p> <p>问：如何把伪代码改写为Python代码？<br/>答：把.txt改成.py即可。</p> <p>Python的自文档性非常好，即便完全不懂编程的人，看到Python的代码，也能猜的出代码想实现什么功能。</p> <p>请大家对比下面两种写法：</p> <p>和</p> <p>如果让一个完全不会编程的人来看，他看到第一段代码，会猜测：“findall是查找全部，这段代码可能是要从sentence找什么东西”。</p> <p>而如果让他看第二段代码，他肯定会先问一句：“compile？编译？什么是编译？编写翻译吗？”</p> <p>而对于刚刚学编程的人来说，如果他看的Python正则表达式入门的文档里面用了<code>re.compile</code>，他也会很疑惑，为什么要<code>compile</code>？编译成了什么东西？为什么不能直接查询？于是新人可能会过早去研究底层的东西。</p> <p>但如果他看的文章直接是<code>re.findall</code>，那么语义非常明确：<code>正则表达式.查询所有</code>，一目了然，轻轻松松就能理解并学会。</p> <p>当我们学习一门新的语言的时候，第一应该参考的就是它的官方文档。在正则表达式官方文档<a href="https://docs.python.org/3/library/re.html#finding-all-adverbs" rel="noopener" target="_blank">https://docs.python.org/3/library/re.html#finding-all-adverbs</a>的例子中，无论是<code>search</code>还是<code>findall</code>都是使用<code>re.xxx</code>的形式。如下图所示：</p> <p><img alt="" src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-08-17-22-57-21.png"/></p> <p><img alt="" src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-08-17-22-57-43.png"/></p> <p>所以网上那些首先使用<code>pattern = re.compile</code>，再<code>pattern.xxx</code>的人，要不就是直接从其他语言把先<code>compile</code>再查询的思维定势带到了Python中，要不就是做正则表达式调优做太久了，思维僵化了，一抬手就是<code>re.compile</code>。</p> <p>在我文章的评论里面，有人说，应该面向接口编程，而不是面向实现编程。</p> <p>对这些人，我想跟你们讲：你们对面向接口编程，理解得太狭隘了！</p> <p>我们来看看，在Python著名的http库<code>requests</code>出来之前，使用<code>urllib2</code>发起一个请求是怎么写的：</p> <p>有了<code>requests</code>以后，实现同样的功能，我们是这样写的：</p> <p>大家自己品位一下，<code>req = urllib2.Request(gh_url)</code>如果类比为<code>pattern = re.compile('xxxx')</code>，<code>handler = urllib2.urlopen(req)</code>类比为<code>pattern.findall(sentence)</code> 那么，<code>requests.get(xxx)</code>就是<code>re.findall</code>。</p> <p>为什么我们现在愿意使用<code>requests</code>而不愿意使用<code>urllib2</code>？</p> <p>因为<code>requests</code>是<strong>for human</strong>，而<code>urllib</code>是<code>for interface</code>.</p> <p>在评论里面，竟然有人质疑我使用<code>re.findall</code>，正则表达式不好维护？</p> <p>@Manjusaka竟然举出了下面这样的例子：</p> <p><img alt="" src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-08-17-23-24-58.png"/></p> <p>为什么使用<code>re.findall</code>，就一定要把正则表达式复制粘贴很多遍？</p> <p>我单独定义一个文件不行吗：</p> <p>然后我要使用正则表达式的地方直接导入进来：</p> <p>请问哪里不好维护了？根本不会出现@Manjusaka说的那种情况。</p> <p>我的观点如下：</p> <p>以下内容与本次讨论的re.compile无关。</p> <p>@Manjusaka给出了一个compile需要3秒钟的大型正则表达式，并以此作为例子说明re.compile的合理性。</p> <p>首先这种情况下，确实需要提前re.compile。</p> <p>但我所想表达的是，在这种情况下，就不应该使用正则表达式。既然要做Redis的语法校验，那么就应该使用有限状态机。这种使用很多的f表达式拼出来的正则表达式，才是真正的难以维护，难以阅读。</p> <p>否则为什么里面需要用一个csv文件来存放命令呢？为什么不直接写在正则表达式里面呢？使用CSV文件每行一个命令尚且可以理解，但是<code>SLOT</code>/<code>SLOTS</code>/<code>NODE</code>/<code>NEWKWY</code>这些正则表达式，可就说不过去了。或条件连接的每一段都要加上这些东西，如果直接写进去，这个正则表达式你们自己都看不下去了，所以才会需要使用拼接的方式生成。</p> <p>我在读这段代码的时候，首先看到正则表达式里面的<code>t[xxx]</code>，会先去找<code>t</code>是什么东西，发现t是一个字典，字典是在<code>commands_csv_loader.py</code>中生成的，然后去到这个文件里面，发现它读的是一个存放Redis命令的CSV文件。然后去项目根目录读取这个csv文件的内容，知道了它的结构，于是推测出t的结构。然后再回到正则表达式里面，继续看这个超大的正则表达式。整个过程会非常费时间和脑子。</p> <p>但是，我又不能直接打印REDIS_COMMANDS这个变量，因为它多且乱，不同命令长短不一，拼出来以后再打印出来根本没法看。</p> <p>这个正则表达式只有两位维护者知道什么意思，如果别人想贡献新的Redis命令，那么理解这个超大正则表达式都需要花很久的时间。</p> <p>如果换成有限状态机，并且t使用Python的data class来表示，而不是使用字典，那么就会简洁很多。有限状态机的一个特点是，只需要关注当前状态、转移条件和目标状态，可能一开始写起来有点麻烦，但是以后维护和新增，都是直接定位目标，直接修改，不用担心会影响不想干的其他地方。</p> <p>算上维护时间，正则表达式真是一个非常糟糕的方式。</p> <p class="site-author-name" itemprop="name">谢乾坤 | Kingname</p> <p class="site-description motion-element" itemprop="description">高级数据挖掘工程师，《Python 爬虫开发 从入门到实战》、《左手 MongoDB 右手 Redis——从入门到商业实战》作者。 微软最有价值专家 MVP，Python Scrapy MongoDB Redis Pandas Golang。</p>
    </body>
    </html>
    