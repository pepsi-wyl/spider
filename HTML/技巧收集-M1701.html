 
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
    </head>
    <body>
    <p class="site-subtitle">给时光以生命。</p> <p>To use the decorator apply it as innermost decorator to a view function. When applying further decorators <em>always</em> remember that the <code>route()</code> decorator is the outermost.</p> <p>HTML的<code>&lt;select&gt;&lt;/select&gt;</code>标签可以实现下拉选择框。<br/><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">class</span>=<span class="string">"form-control"</span>&gt;</span></span><br/><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"admin"</span> <span class="attr">selected</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br/><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"admin"</span>&gt;</span>viewer<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br/><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"admin"</span>&gt;</span>guest<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br/><span class="line"></span><br/><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br/></pre></td></tr></table></figure></p> <p>运行效果如下：</p> <p><select class="form-control"><br/> <option selected="" value="admin">admin</option><br/> <option value="admin">viewer</option><br/> <option value="admin">guest</option><br/></select></p> <p>通过二进制的位操作，可以简化很多问题的分析。</p> <p>例如现在有四个角色，分别为：读者，作者，编辑和管理员。有四个不同的权限使用四位的二进制数表示：</p> <p>每个角色的权限如下：</p> <p>要判断一个角色有哪些权限，人眼可以直接看对应的位置上面是0还是1，是0就是没有权限，是1就是有权限。在程序里面可以通过和对应权限的四位二进制数取位与操作。例如，0111编辑是否有写权限？因为0111 &amp; 0010 = 0010 所以有写权限。只要角色的四位二进制数和权限的四位二进制数取位与，得到的结果还是权限的四位二进制数，那么就有这个权限。</p> <p>正常情况下人有十根手指，所以一共可以计数1023个，但是一般在计数到第4个数的时候你就会挨打。明白二进制的自然知道我说的是什么意思。不明白二进制的，请看下面的动图：<br/><img alt="手指使用二进制计数" src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/count.gif"/></p> <p>Markdown在写作方面有非常好的优势，可以让写作的人不用关心格式，从而专注于要写的内容。但是Markdown不能进行缩进，这导致在一些大纲类的文本信息的显示上不太友好。<a href="https://workflowy.com/invite/4b7e29eb.lnx" rel="noopener" target="_blank">Workflowy</a>的出现可以解决这个问题。Workflowy只支持文本，界面极其简洁：<br/><img alt="" src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2017-01-28-16-59-48.png"/><br/>通过它来创建一个大纲，有助于理清思路。</p> <p>在HTML的<code>&lt;form&gt;&lt;/form&gt;</code>表单中，有一个属性叫做<code>action</code>它的值是空或者是一个URL的相对路径或绝对路径。如果为空，表单将会被提交到现在这个页面的URL；如果不为空，表单将会被提交到action的值对应的页面来处理。</p> <p>理解这一点，那些喜欢在Flask中，把GET和POST写到一个Route，同时又要为GET带参数的人，需要特别注意。因为当你POST的时候，如果action不为空，参数可能会被丢失。</p> <p>如果你想在局域网中共享一个文件，你可以通过Python 3快速完成：</p> <p>在Python中，使用<code>yield</code>实现生成器。生成器的性质是只有在被迭代的时候才运行其内部的代码。这样可以大大降低内存的占用。除此之外，<code>yield</code>还可以接收参数供生成器内部使用。<br/><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generator</span><span class="params">(top)</span>:</span></span><br/><span class="line">       index = <span class="number">0</span></span><br/><span class="line">       <span class="keyword">while</span> index &lt;= top:</span><br/><span class="line">              value_from_out = <span class="keyword">yield</span> index ** <span class="number">2</span></span><br/><span class="line">              print(<span class="string">'来自外面的值为：{}'</span>.format(value_from_out))</span><br/><span class="line">              index += <span class="number">1</span></span><br/><span class="line"></span><br/><span class="line">power_2 = generator(<span class="number">10</span>)</span><br/><span class="line">print(next(power_2))</span><br/><span class="line">print(next(power_2))</span><br/><span class="line">print(power_2.send(<span class="string">"next(power_2) 相当于power_2.send(None)"</span>))</span><br/><span class="line">print(next(power_2))</span><br/><span class="line">print(power_2.send(<span class="string">'代码在函数和这里来回跳。'</span>))</span><br/></pre></td></tr></table></figure></p> <p>输出结果为：<br/><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/></pre></td><td class="code"><pre><span class="line">0</span><br/><span class="line">来自外面的值为：None</span><br/><span class="line">1</span><br/><span class="line">来自外面的值为：next(power_2) 相当于power_2.send(None)</span><br/><span class="line">4</span><br/><span class="line">来自外面的值为：None</span><br/><span class="line">9</span><br/><span class="line">来自外面的值为：代码在函数和这里来回跳。</span><br/><span class="line">16</span><br/></pre></td></tr></table></figure></p> <p>以上的运行方式，和协程非常的相似。</p> <p><a href="https://zh.wikipedia.org/wiki/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E7%A4%BA%E6%B3%95" rel="noopener" target="_blank">逆波兰式</a>通过栈来实现对表达式的运算。例如：</p> <p>中缀表达式: 5 + ((1 + 2) <em> 4) − 3<br/>逆波兰式：5 1 2 + 4 </em> + 3 −</p> <p>使用<a href="https://zh.wikipedia.org/wiki/%E8%B0%83%E5%BA%A6%E5%9C%BA%E7%AE%97%E6%B3%95" rel="noopener" target="_blank">调度场算法</a>可以将中缀表达式转换为逆波兰式。调度场算法是通过栈来实现的。操作数直接输出，符号需要判断优先级来判断应该直接压栈还是直接输出或者应该先将栈顶元素输出再压栈。</p> <p><img alt="调度场算法示意图" src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/170122.png"/></p> <p class="site-author-name" itemprop="name">谢乾坤 | Kingname</p> <p class="site-description motion-element" itemprop="description">高级数据挖掘工程师，《Python 爬虫开发 从入门到实战》、《左手 MongoDB 右手 Redis——从入门到商业实战》作者。 微软最有价值专家 MVP，Python Scrapy MongoDB Redis Pandas Golang。</p>
    </body>
    </html>
    